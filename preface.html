<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
		<link title="David R. Hanson" href="http://drh.home.dyndns.org" rev="made">
		<link href="style.css" type="text/css" rel="stylesheet" media="all">
		<title>Preface for C Interfaces and Implementations</title>
	</head>

	<body>
		<h1>Preface</h1>
		<p>Programmers are inundated with information about application programming interfaces, or APIs. Yet, while most programmers use APIs and the libraries that implement them in almost every application they write, relatively few create and disseminate new, widely applicable, APIs. Indeed, programmers seem to prefer to &ldquo;roll their own&rdquo; instead of searching for a library that might meet their needs, perhaps because it is easier to write application-specific code than to craft well-designed APIs.</p>
		<p>I<a href="http://www.cs.princeton.edu/%7ers/">&rsquo;</a>m as guilty as the next programmer: <a href="http://www.cs.princeton.edu/software/lcc/">lcc</a>, a compiler for ANSI/ISO C written by Chris Fraser and myself, was built from the ground up. (<tt>lcc</tt> is described in C.W. Fraser and D. R. Hanson, <cite>A Retargetable C Compiler: Design and Implementation</cite>, Addison-Wesley, 1995.) A compiler exemplifies the kind of application for which it possible to use standard interfaces and to create interfaces that are useful elsewhere. Examples include interfaces for memory management, string and symbol tables, and list manipulation. But <tt>lcc</tt> uses only a few routines from the standard C library, and almost none of its code can be used directly in other applications.</p>
		<p>This book advocates a design methodology based on interfaces and their implementations, and it illustrates this methodology by describing 24 interfaces and their implementations in detail. These interfaces span a large part of the computing spectrum and include data structures, arithmetic, string processing, and concurrent programming. The implementations aren<a href="http://www.cs.princeton.edu/%7ers/">&rsquo;</a>t toys&#151;they&rsquo;re designed for use in production code. As described below, the source code is freely available.</p>
		<p>There&rsquo;s little support in the C programming language for the interface-based design methodology. Object-oriented languages, like C++ and Modula-3, have language features that encourage the separation of an interface from its implementation. Interface-based design is independent of any particular language, but it does require more programmer willpower and vigilance in languages like C, because it&rsquo;s too easy to pollute an interface with implicit knowledge of its implementation and vice versa.</p>
		<p>Once mastered, however, interface-based design can speed development time by building upon a foundation of general-purpose interfaces that can serve many applications. The foundation class libraries in some C++ environments are examples of this effect. Increased reuse of existing software&mdash;libraries of interface implementations&mdash;reduces initial development costs. It also reduces maintenance costs, because more of an application rests on well-tested implementations of general-purpose interfaces.</p>
		<p>The 24 interfaces come from several sources, and all have been revised for this book. Some of the interfaces for data structures&mdash;abstract data types&mdash;originated in <code>lcc</code> code, and in implementations of the <a href="http://www.cs.arizona.edu/icon/">Icon programming language</a> done in the late 1970s and early 1980s (see R. E. Griswold and M. T. Griswold, <cite>The Icon Programming Language</cite>, Prentice Hall, 1990). Others come from the published work of other programmers; the &ldquo;Further Reading&rdquo; sections at the end of each chapter give the details.</p>
		<p>Some of the interfaces are for data structures, but this is not a data structures book, per se. The emphasis is more on algorithm engineering&mdash;packaging data structures for general use in applications&mdash;than on data-structure algorithms. Good interface design does rely on appropriate data structures and efficient algorithms, however, so this book complements traditional data structure and algorithms texts like <a href="http://www.cs.princeton.edu/rs/">Robert Sedgewick&rsquo;s</a> <a href="http://www.aw-bc.com/catalog/academic/product/0,1144,0805316701,00.html"><cite>Algorithms in C</cite></a> (Addison-Wesley, 1998).</p>
		<p>Most chapters describe one interface and its implementation; a few describe related interfaces. The &quot;Interface&quot; section in each chapter gives a concise, detailed description of the interface alone. For programmers interested only in the interfaces, these sections form a reference manual. A few chapters include &ldquo;Example&rdquo; sections, which illustrate the use of one or more interfaces in simple applications.</p>
		<p>The &ldquo;Implementation&rdquo; section in each chapter is a detailed tour of the code that implements the chapter&rsquo;s interface. In a few cases, more than one implementation for the same interface is described, which illustrates an advantage of interface-based design. These sections are most useful for those modifying or extending an interface or designing related interfaces. Many of the exercises explore design and implementation alternatives. It should not be necessary to read an &ldquo;Implementation&rdquo; section in order to understand how to use an interface.</p>
		<p>The interfaces, examples, and implementations are presented as <em>literate programs</em>; that is, the source code is interleaved with its explanation in an order that best suits understanding the code. The code is extracted automatically from the text files for this book and assembled into the order dictated by the C programming language. Other book-length examples of literate programming in C include <cite>A Retargetable C Compiler</cite> and <cite>The Stanford GraphBase: A Platform for Combinatorial Computing</cite> by D.E. Knuth (Addison-Wesley, 1993).</p>
		<h2>Organization</h2>
		<p>The material in this book falls into the following broad categories:</p>
		<blockquote>
			<table cellpadding="12">
				<tr align="LEFT" valign="TOP">
					<td><i>Foundations</i></td>
					<td>1. Introduction<br>
						2. Interfaces and Implementations<br>
						4. Exceptions and Assertions<br>
						5. Memory Management<br>
						6. More Memory Management</td>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td><i>Data Structures</i></td>
					<td>7. Lists<br>
						8. Tables<br>
						9. Sets<br>
						10. Arrays<br>
						11. Sequences<br>
						12. Rings<br>
						13. Bit Vectors</td>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td><i>Strings</i></td>
					<td>3. Atoms<br>
						14. Formatting<br>
						15. Low-Level Strings<br>
						16. High-Level Strings</td>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td><i>Arithmetic</i></td>
					<td>17. Extended-Precision Arithmetic<br>
						18. Arbitrary-Precision Arithmetic<br>
						19. Multiple-Precision Arithmetic</td>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td><i>Threads</i></td>
					<td>20. Threads</td>
				</tr>
			</table>
		</blockquote>
		<p>Most readers will benefit from reading all of Chapters 1 through 4, because these chapters form the framework for the rest of the book. The remaining chapters can be read in any order, although some of the later chapters refer to their predecessors.</p>
		<p>Chapter 1 covers literate programming and issues of programming style and efficiency. Chapter 2 motivates and describes the interface-based design methodology, defines the relevant terminology, and tours two simple interfaces and their implementations. Chapter 3 describes the prototypical <tt>Atom</tt> interface, which is the simplest production-quality interface in this book. [<a href="http://ciibook.webhop.net/pdf/atom.pdf">Download/view Chapter 3</a>, an Adobe Acrobat PDF file (52K).] Chapter 4 introduces exceptions and assertions, which are used in every interface. Chapters 5 and 6 describe the memory management interfaces used by almost all the implementations. The rest of the chapters each describe an interface and its implementation.</p>
		<h2>Instructional Use</h2>
		<p>I assume that readers understand C at the level covered in undergraduate introductory programming courses, and have a working understanding of fundamental data structures at the level presented in texts like <cite>Algorithms in C</cite>. At Princeton, the material in this book is used in systems programming courses from the sophomore to first-year graduate levels. Many of the interfaces use advanced C programming techniques, such as opaque pointers and pointers to pointers, and thus serve as nontrivial examples of those techniques, which are useful in systems programming and data structure courses.</p>
		<p>This book can be used for courses in several ways, the simplest being in project-oriented courses. In a compiler course, for example, students often build a compiler for a toy language. Substantial projects are common in graphics courses as well. Many of the interfaces can simplify the projects in these kinds of courses by eliminating some of the grunt programming needed to get such projects off the ground. This usage helps students realize the enormous savings that reuse can bring to a project, and it often induces them to try interface-based design for their own parts of the project. This latter effect is particularly valuable in team projects, because that&rsquo;s a way of life in the &ldquo;real world.&rdquo;</p>
		<p>Interfaces and implementations are the focus of Princeton&rsquo;s sophomore-level systems programming course. Assignments require students to be interface clients, implementors, and designers. In one assignment, for example, I distribute Section 8.1&rsquo;s <code>Table</code> interface, the object code for its implementation, and the specifications for Section 8.2&rsquo;s word frequency program, <code>wf</code>. The students must implement <code>wf</code> using only my object code for <code>Table</code>. In the next assignment, they get the object code for <code>wf</code>, and they must implement <code>Table</code>. Sometimes, I reverse these assignments, but both orders are eye-openers for most students. They are unaccustomed to having only object code for major parts of their program, and these assignments are usually their first exposure to the semiformal notation used in interfaces and program specification.</p>
		<p>Initial assignments also introduce checked runtime errors and assertions as integral parts of interface specifications. Again, it takes a few assignments before students begin to appreciate the value of these concepts. I forbid &quot;unannounced&quot; crashes; that is, crashes that are not announced by an assertion failure diagnostic. Programs that crash get a grade of zero. This penalty may seem unduly harsh, but it gets the students&rsquo; attention. They also gain an appreciation of the advantages of safe languages, like ML and Modula-3, in which unannounced crashes are impossible. <small>(This grading policy is less harsh than it sounds, because in multipart assignments, only the offending part is penalized, and different assignments have different weights. I&rsquo;ve given many zeros, but none has ever caused a course grade to shift by a whole point.)</small></p>
		<p>Once students have a few interfaces under their belts, later assignments ask them to design new interfaces and to live with their design choices. For example, one of <a href="http://www.cs.princeton.edu/%7eappel/">Andrew Appel</a>&rsquo;s favorite assignments is a primality testing program. Students work in groups to design the interfaces for the arbitrary-precision arithmetic that is needed for this assignment. The results are similar to the interfaces described in Chapters 17 through 19. Different groups design interfaces, and a postassignment comparison of these interfaces, in which the groups critique on one anothers&rsquo; work, is always quite revealing. <a href="http://www.cs.princeton.edu/%7eli/">Kai Li</a> accomplishes similar goals with a semester-long project that builds an X-based editor using the <a href="http://www.tcl.tk">Tcl/Tk system</a> (J.K. Ousterhout, <cite>Tcl and the Tk Toolkit</cite>, Addison-Wesley, 1994) and editor-specific interfaces designed and implemented by the students. Tk itself provides another good example of interface-based design.</p>
		<p>In advanced courses, I usually package assignments as interfaces and give the students free rein to revise and improve on them, and even to change the goals of the assignment. Giving them a starting point reduces the time required for assignment, and allowing substantial changes encourages creative students to explore alternatives. The unsuccessful alternatives are often more educational than the successful ones. Students invariably go down the wrong road, and they pay for it with greatly increased development time. When, in hindsight, they understand their mistakes, they come to appreciate that designing good interfaces is hard, but worth the effort, and they almost always become converts to interface-based design.</p>
		<h2>How to Get the Software</h2>
		<p>The software in this book has been tested on the following platforms.</p>
		<blockquote>
			<table cellpadding="12">
				<tr align="LEFT" valign="TOP">
					<th><i>Processor</i></th>
					<th><i>Operating Systems</i></th>
					<th><i>Compilers</i></th>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td align="LEFT">SPARC</td>
					<td>SunOS 4.1</td>
					<td>lcc 3.5<br>
						gcc 2.7.2</td>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td>Alpha</td>
					<td>OSF/1 3.2A</td>
					<td>lcc 4.0<br>
						gcc 2.6.3<br>
						cc</td>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td>MIPS R3000</td>
					<td>IRIX 5.3</td>
					<td>lcc 3.5<br>
						gcc 2.6.3<br>
						cc</td>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td>MIPS R3000</td>
					<td>Ultrix 4.3</td>
					<td>lcc 3.5<br>
						gcc 2.5.7</td>
				</tr>
				<tr align="LEFT" valign="TOP">
					<td>Pentium</td>
					<td>Windows 95<br>
						Windows NT 3.51<br>
						<small>(except for Threads)</small></td>
					<td>Microsoft Visual C/C++ 4.0</td>
				</tr>
			</table>
		</blockquote>
		<p>A few of the implementations are machine-specific; they assume that the machine has two&rsquo;s-complement integer and IEEE floating-point arithmetic, and that unsigned longs can hold object pointers.</p>
		<p>The source code for everything in this book is available on the Downloads page at <a href="http://code.google.com/p/cii">http://code.google.com/p/cii</a>. The most recent distributions are in files named <tt>cii</tt><i>xy</i><tt>.tar.gz</tt> or <tt>cii</tt><i>xy</i><tt>.zip</tt>. <i>xy</i> is the version number, e.g., 11 is version 1.1. <tt>cii</tt><i>xy</i><tt>.tar.gz</tt> is a U<small>NIX</small> tar file compressed with <tt>gzip</tt>, and <tt>cii</tt><i>xy</i><tt>.zip</tt> is a ZIP file compatible with PKZIP version 2.04g. The files in <tt>cii</tt><i>xy</i><tt>.zip</tt> are DOS/Windows text files; that is, their lines end with carriage returns and linefeeds.</p>
		<p>Information is also available at <a href="http://www.cs.princeton.edu/software/cii/">http://www.cs.princeton.edu/software/cii/</a>. This page includes instructions on reporting bugs.</p>
		<h2>Acknowledgments</h2>
		<p>I have been using some of the interfaces in this book for my own research projects and in courses at the University of Arizona and Princeton University since the late 1970s. Students in these courses have been guinea pigs for my drafts of these interfaces. Their feedback over the years has been an important contribution to both the code in this book and its explanation. The Princeton students in several offerings of COS 217 and COS 596 deserve special thanks, because they suffered unknowingly through the drafts of most of what&rsquo;s in this book.</p>
		<p>Interfaces are a way of life at Digital&rsquo;s System Research Center (SRC), and my 1992 and 1993 summers at SRC working on the Modula-3 project erased any doubts I may have harbored about the efficacy of this approach. My thanks to SRC for supporting my visits, and to Bill Kalsow, Eric Muller, and Greg Nelson for many illuminating discussions.</p>
		<p>My thanks to IDA&rsquo;s Centers for Communications Research in Princeton and La Jolla for their support during the summer of 1994 and during my 1995&#150;96 sabbatical. The CCRs provided ideal hideouts at which to plan and complete this book.</p>
		<p>Technical interactions with colleagues and students have contributed to this book in many ways. Even seemingly unrelated discussions have provoked improvements in my code and in its explanation. Thanks to Andrew Appel, Greg Astfalk, Jack Davidson, John Ellis, Mary Fern&aacute;ndez, Chris Fraser, Alex Gounares, Kai Li, Jacob Navia, Maylee Noah, Rob Pike, Bill Plauger, John Reppy, Anne Rogers, and Richard Stevens. Careful readings of my code and prose by Rex Jaeschke, Brian Kernighan, Taj Khattra, Richard O&rsquo;Keefe, Norman Ramsey, and David Spuler made a significant contribution to the quality of both.</p>
		<p><a href="./">Back to the CII home page</a>.</p>
		<hr>
		<address><a href="http://drh.home.dyndns.org">David Hanson</a><br>
			$Revision$ $Date$</address>
	</body>

</html>